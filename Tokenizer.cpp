#include <iostream>
#include "Tokenizer.h"

/// Имплементация на клас Tokenizer

/**
 * Конструктор с параметър от тип char*.
 * Той инициализира член-данната this->str с подадения като параметър str, а на позицията pos се задава стойност 0.
*/

Tokenizer::Tokenizer(char* str)
{
    this->str = str;
    this->pos = 0;
}

/**
 * Метод next().
 * В началото му се създава променлива от тип bool, чиято цел е да проверява за наличието на ""(quotes). По подразбиране е зададена стойност false.
 * След това посредством while цикъл се проверява наличието на интервали в началото, и ако такива има - те се изчитат. Позицията се увеличава при изчитането на интервал.
 * С if условие се прави проверка дали елементът от масива str, който се посочва от pos, не е \0. Ако имаме \0 връщаме nullptr - значи масивът вече е празен.
 * С още едно if условие проверяваме за наличието на кавички. Ако такива има променяме стойността на булевата променлива quotes на true и преместваме позицията с 1 надясно.
 * Тази проверка е нужна, защото потребителят може да реши да въведе вход от типа "open"
 * Създаваме нова променлива от тип int с име start, която показва началото на дадена дума/команда, която ще се чете.
 * След това се прави проверка с помощта на while цикъл, който действа до срещането на \0.
 * Ако имаме отварящи " и срещнем затварящи ", то следва, че дадената дума е изчетена и излизаме от цикъла.
 * Ако пък няма срещане на ", а има на интервал, тогава цикълът отново приключва, защото се приема, че дадената дума е изчетена.
 * Ако тези две условия не са изпълнени, тогава позицията се мести с 1 надясно и цикълът продължава.
 * Когато се излезе от цикъла while, то със сигурност имаме изчетена дума, чиято дължина можем да разберем, при изваждането на start от pos, 
 * защото start сочи позицията, от която сме почнали да четем дума, а pos е позицията, на която се намираме в момента, при вече изчетена дума.
 * Дължината на думата се запаметява в променливата size.
 * Тъй като str съдържа масив, в който има смесица от букви, интервали и знаци, се нуждаем от втори масив, в който да съхраним само изчетена дума.
 * Затова създаваме такъв - token, с динамично заделена памет size + 1 за \0.
 * С помощтта на for цикъл копираме думата от str в token, като на последната позиция на масива token поставяме \0.
 * Нужно е, да се направи една последна проверка - ако сме изчели ", то трябва да приместим позицията на четене pos с 1 надясно, 
 * за да не се полуава грешка и затварящата " да бъде прочетена като отваряща ", след която да се очаква изчитане на дума.
 * Накрая на метода връщаме изчетената дума token.
*/

char* Tokenizer::next()
{
    bool quotes = false;

    while(str[pos] == ' ')
    {
        pos++; 
    }

    if(str[pos] == '\0')
    {
        return nullptr;
    }
    
    if(str[pos] == '"')
    {
        quotes = true;
        pos++;
    }

    int start = pos;

    while(str[pos] != '\0')
    {
        if(quotes) 
        {
            if(str[pos] == '"')
            {
                break;
            }
        }
        else
        {
            if(str[pos] == ' ')
            {
                break;
            }
        }
        pos++;
    }

    int size = pos - start;

    char* token = new char[size + 1];

    int i;
    for (i = 0; i < size; i++)
    {
        token[i] = str[start + i];
    }
    token[i] = '\0';

    if(quotes) // ако имаме текст в кавички трябва да изместим позицията с 1 нататък, за да не четем затварящата кавичка като отваряща
    {
        pos++;
    }
    
    return token;
}

