#ifndef DYNARRAY_H_
#define DYNARRAY_H_

/**
 * Собствена имплементация на част от контейнера vector с името DynArray.
 * Шаблонният клас DynArray е масив, който може да съхранява обекти от различни типове.
 * Състои се от две частни член-данни, конструктор по подразбиране, деструктор, предефиниране на оператор и няколко метода.
*/

template <class T>
class DynArray
{
private:
    T* array; ///< шаблонен масив със заделяне на динамична памет array.
    int size; ///< променлива от тип int, указваща размера на масива.

public:
    /**
     * Конструктор по подразбиране, който задава стойност 0 за размера, а указателят към динамичната памет, която ще се задели за масива, 
     * в момента не сочи никъде.
    */

    DynArray() : array(nullptr), size(0) {} 

    DynArray<T>& operator=(const DynArray<T>& other)
    {
        size = other.size;
        array = new T[size];
        
        for(int i = 0; i < size; i++)
            array[i] = other.array[i];
        
        return *this;
    }

    /**
     * Деструктор, който освобождава динамично заделената памет за array.
    */

    ~DynArray()
    {
        delete[] array;
    }

    /**
     * Предефиниране на оператор[] - оператор за индексиране елемент от масив.
     * Приема променлива i(index) от целочислен тип, която сочи позиция в масива.
     * Чрез нея се връща елемента на зададената позиция, който елемент е от тип T&, тъй като класът е шаблонен.
    */

    T& operator[](int i)
    {
        return array[i];
    }

    /**
     * Метод add(): добавя елемент от тип T в края на масив.
     * Създава се временен масив temp, за който се заделя памет с размер size + 1, при което size показва досегашния размер на array, а +1 е за \0.
     * Чрез for цикъл елементите от array се прехвърлят в temp, а след това на последното място в масива temp, сочено от размера на масива, 
     * се добавя и подадения като параметър елемент.
     * Паметта, към която array до момента е сочил, се освобождава, а указателят е пренасочен към temp.
     * Размерът на array се увеличава с 1, за да има място за последно добавения елемент.
     * Накрая връщаме елемента, като затова използваме индекс size - 1, тъй като размерът вече е нарастнал с единица,
     * а търсеният елемент се нарима на индекс size.
    */

    T& add(T element)
    {
        T* temp = new T[size + 1];
        for (int i = 0; i < size; i++)
        {
            temp[i] = array[i];
        }
        temp[size] = element;
        delete[] array;
        array = temp;
        size++;
        return array[size - 1]; // връща елемента
    }

    /**
     * Метод remove(): премахва елемент от посочената като параметър позиция.
     * Заделя се временен масив с размер колкото сочената позиция, от която ще се премахва елемент.
     * След това се извърта for цикъл, докато елементите до индекс position от array не се копират в temp.
     * След това с помощтта на втори for цикъл, започващ от позицията, на която се премахва елемента, се копират и останалите елементи от array в temp.
     * Освобождава се динамично заделената памет на array, а указателят се премества към паметта на temp.
     * Размерът се намаля с единица, тъй като вече елементите са с един по-малко.
    */

    void remove(int position)
    {
        T* temp = new T[size - 1];
        for (int i = 0; i < position; i++)
        {
            temp[i] = array[i];
        }
        for (int i = position; i < size; i++)
        {
            temp[i] = array[i + 1];
        }
        delete[] array;
        array = temp;
        size--;
    }

    /// Метод length() - осигурява достъп до частната член-данна size. Getter.

    int length()
    {
        return this->size;
    }
};

#endif